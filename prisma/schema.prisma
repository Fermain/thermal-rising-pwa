// This is your Prisma schema file,
// learn more about it in the docs: https://pris.ly/d/prisma-schema

generator client {
    provider        = "prisma-client-js"
    previewFeatures = ["jsonProtocol"]
}

datasource db {
    provider = "postgresql"
    // NOTE: When using mysql or sqlserver, uncomment the @db.Text annotations in model Account below
    // Further reading:
    // https://next-auth.js.org/adapters/prisma#create-the-prisma-schema
    // https://www.prisma.io/docs/reference/api-reference/prisma-schema-reference#string
    url      = env("DATABASE_URL")
}

// Necessary for Next auth
model Account {
    id                String  @id @default(uuid())
    userId            String
    type              String
    provider          String
    providerAccountId String
    refresh_token     String? // @db.Text
    access_token      String? // @db.Text
    expires_at        Int?
    token_type        String?
    scope             String?
    id_token          String? // @db.Text
    session_state     String?
    user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([provider, providerAccountId])
}

model VerificationToken {
    identifier String
    token      String   @unique
    expires    DateTime

    @@unique([identifier, token])
}

model Session {
    id           String   @id @default(uuid())
    sessionToken String   @unique
    userId       String
    expires      DateTime
    user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model User {
    id            String       @id @default(uuid())
    name          String?
    email         String?      @unique
    emailVerified DateTime?
    phone         String?
    image         String?
    accounts      Account[]
    sessions      Session[]
    inspections   Inspection[]
    createdAt     DateTime     @default(now())
    updatedAt     DateTime     @updatedAt
    roles         Role         @relation(fields: [roleId], references: [id], onDelete: Cascade)
    roleId        String
}

model Role {
    id    String   @id @default(uuid())
    name  String   @unique
    users User[]
    type  RoleType

    createUser Boolean @default(false)
    updateUser Boolean @default(false)
    deleteUser Boolean @default(false)
    readUser   Boolean @default(false)

    createSite Boolean @default(false)
    updateSite Boolean @default(false)
    deleteSite Boolean @default(false)
    readSite   Boolean @default(false)

    createInspection Boolean @default(false)
    updateInspection Boolean @default(false)
    deleteInspection Boolean @default(false)
    readInspection   Boolean @default(false)

    createMachine Boolean @default(false)
    updateMachine Boolean @default(false)
    deleteMachine Boolean @default(false)
    readMachine   Boolean @default(false)

    createChecklist Boolean @default(false)
    updateChecklist Boolean @default(false)
    deleteChecklist Boolean @default(false)
    readChecklist   Boolean @default(false)

    createChecklistItem Boolean @default(false)
    updateChecklistItem Boolean @default(false)
    deleteChecklistItem Boolean @default(false)
    readChecklistItem   Boolean @default(false)

    createReport Boolean @default(false)
    updateReport Boolean @default(false)
    deleteReport Boolean @default(false)
    readReport   Boolean @default(false)
}

enum RoleType {
    INSPECTOR
    MANAGER
    GOD
}

model Site {
    id           String       @id @default(uuid())
    name         String       @unique
    street       String
    municipality String
    province     String
    postalCode   String
    country      String       @default("South Africa")
    phone        String?
    email        String?
    userId       String
    equipment    Machine[]
    Inspection   Inspection[]
    createdAt    DateTime     @default(now())
    updatedAt    DateTime     @updatedAt
}

model Machine {
    id          String              @id @default(uuid())
    name        String
    site        Site                @relation(fields: [siteId], references: [id], onDelete: Cascade)
    siteId      String
    checks      ChecklistItem[]
    inspections MachineInspection[]
    createdAt   DateTime            @default(now())
}

model ChecklistItem {
    id          String             @id @default(uuid())
    machineId   String
    machine     Machine            @relation(fields: [machineId], references: [id], onDelete: Cascade)
    description String
    results     InspectionResult[]
}

model Inspection {
    id          String              @id @default(uuid())
    date        DateTime // Date of inspection 
    inspector   User                @relation(fields: [inspectorId], references: [id], onDelete: Cascade)
    inspectorId String
    machines    MachineInspection[]
    results     InspectionResult[]
    site        Site                @relation(fields: [siteId], references: [id], onDelete: Cascade)
    siteId      String
    createdAt   DateTime            @default(now())
}

model MachineInspection {
    machineId    String
    machine      Machine    @relation(fields: [machineId], references: [id], onDelete: Cascade)
    inspectionId String
    inspection   Inspection @relation(fields: [inspectionId], references: [id], onDelete: Cascade)

    @@id([machineId, inspectionId])
}

model InspectionResult {
    id              String           @id @default(uuid())
    inspectionId    String
    inspection      Inspection       @relation(fields: [inspectionId], references: [id], onDelete: Cascade)
    checklistItemId String
    checklistItem   ChecklistItem    @relation(fields: [checklistItemId], references: [id], onDelete: Cascade)
    status          InspectionStatus
    message         String? // Optional, use only when the status is "failed"
    photo           String? // Optional, use only when the status is "failed"
    signature       String? // Signature URL for each inspection result or should it be on the inspection itself?
}

enum InspectionStatus {
    PASSED
    FAILED
}
